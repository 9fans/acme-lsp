// Package text implements text editing helper routines for LSP.
package text

import (
	"bytes"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"strconv"
	"strings"

	"github.com/fhs/acme-lsp/internal/golang_org_x_tools/span"
	"github.com/fhs/acme-lsp/internal/lsp/protocol"
)

// File represents an open file in text editor.
type File interface {
	// Reader returns a reader for the entire file text buffer ("body" in acme).
	Reader() (io.Reader, error)

	// WriteAt replaces the text in rune range [q0, q1) with bytes b.
	WriteAt(q0, q1 int, b []byte) (int, error)

	// Mark marks the file for later undo.
	Mark() error

	// DisableMark turns off automatic marking (e.g. generated by WriteAt).
	DisableMark() error
}

// Edit applied edits to file f.
func Edit(f File, edits []protocol.TextEdit) error {
	if len(edits) == 0 {
		return nil
	}

	reader, err := f.Reader()
	if err != nil {
		return err
	}
	off, err := getNewlineOffsets(reader)
	if err != nil {
		return fmt.Errorf("failed to obtain newline offsets: %v", err)
	}

	if span := edits[0].Range; len(edits) == 1 && span.Start.Line == 0 && span.Start.Character == 0 && int(span.End.Line) >= len(off.nl)-1 {
		reader, err := f.Reader()
		if err != nil {
			return err
		}
		p, err := ioutil.ReadAll(reader)
		if err != nil {
			return err
		}
		edits, err = diffEdits(p, []byte(edits[0].NewText))
		if err != nil {
			return err
		}
	}

	f.DisableMark()
	f.Mark()

	// Applying the edits in reverse order gets the job done.
	// See https://github.com/golang/go/wiki/gopls#textdocumentformatting-response
	for i := len(edits) - 1; i >= 0; i-- {
		e := edits[i]
		q0 := off.LineToOffset(int(e.Range.Start.Line), int(e.Range.Start.Character))
		q1 := off.LineToOffset(int(e.Range.End.Line), int(e.Range.End.Character))
		f.WriteAt(q0, q1, []byte(e.NewText))
	}
	return nil
}

// AddressableFile represents an open file in text editor which has a current adddress.
type AddressableFile interface {
	File

	// Filename returns the filesystem path to the file.
	Filename() (string, error)

	// CurrentAddr returns the address of current selection.
	CurrentAddr() (q0, q1 int, err error)
}

// DocumentURI returns the URI and filename of a file being edited.
func DocumentURI(f AddressableFile) (uri protocol.DocumentURI, filename string, err error) {
	name, err := f.Filename()
	if err != nil {
		return "", "", err
	}
	return ToURI(name), name, nil
}

// Position returns the current position within a file being edited.
func Position(f AddressableFile) (pos *protocol.TextDocumentPositionParams, filename string, err error) {
	name, err := f.Filename()
	if err != nil {
		return nil, "", fmt.Errorf("could not get window filename: %v", err)
	}
	q0, _, err := f.CurrentAddr()
	if err != nil {
		return nil, "", fmt.Errorf("could not get current address: %v", err)
	}
	reader, err := f.Reader()
	if err != nil {
		return nil, "", fmt.Errorf("could not get window body reader: %v", err)
	}
	off, err := getNewlineOffsets(reader)
	if err != nil {
		return nil, "", fmt.Errorf("failed to get newline offset: %v", err)
	}
	line, col := off.OffsetToLine(q0)
	return &protocol.TextDocumentPositionParams{
		TextDocument: protocol.TextDocumentIdentifier{
			URI: ToURI(name),
		},
		Position: protocol.Position{
			Line:      float64(line),
			Character: float64(col),
		},
	}, name, nil
}

// ToURI converts filename to URI.
func ToURI(filename string) protocol.DocumentURI {
	return protocol.DocumentURI(span.NewURI(filename))
}

// ToPath converts URI to filename.
func ToPath(uri protocol.DocumentURI) string {
	return span.NewURI(uri).Filename()
}

func diffEdits(old, new []byte) ([]protocol.TextEdit, error) {
	oldTemp, err := tempfile(old)
	if err != nil {
		return nil, err
	}
	defer os.Remove(oldTemp)
	newTemp, err := tempfile(new)
	if err != nil {
		return nil, err
	}
	defer os.Remove(newTemp)

	diff, _ := exec.Command("9", "diff", oldTemp, newTemp).CombinedOutput()

	var diffs []protocol.TextEdit

	// Adapted from acmego.
	diffLines := strings.Split(string(diff), "\n")
	for _, line := range diffLines {
		if line == "" {
			continue
		}
		if line[0] == '<' || line[0] == '-' || line[0] == '>' {
			continue
		}
		j := 0
		for j < len(line) && line[j] != 'a' && line[j] != 'c' && line[j] != 'd' {
			j++
		}
		if j >= len(line) {
			return nil, fmt.Errorf("cannot parse diff line: %q", line)
		}
		oldStart, oldEnd := parseSpan(line[:j])
		newStart, newEnd := parseSpan(line[j+1:])
		if newStart == 0 || (oldStart == 0 && line[j] != 'a') {
			continue
		}
		switch line[j] {
		case 'a':
			diffs = append(diffs, protocol.TextEdit{
				Range: protocol.Range{
					Start: protocol.Position{Line: float64(oldStart - 1)},
					End:   protocol.Position{Line: float64(oldStart - 1)},
				},
				NewText: string(findLines(new, newStart, newEnd)),
			})
		case 'c':
			diffs = append(diffs, protocol.TextEdit{
				Range: protocol.Range{
					Start: protocol.Position{Line: float64(oldStart - 1)},
					End:   protocol.Position{Line: float64(oldEnd)},
				},
				NewText: string(findLines(new, newStart, newEnd)),
			})
		case 'd':
			diffs = append(diffs, protocol.TextEdit{
				Range: protocol.Range{
					Start: protocol.Position{Line: float64(oldStart - 1)},
					End:   protocol.Position{Line: float64(oldEnd - 1)},
				},
				NewText: "",
			})
		}
	}
	if !bytes.HasSuffix(old, nlBytes) && bytes.HasSuffix(new, nlBytes) {
		numOldLines := bytes.Count(old, nlBytes)
		diffs = append(diffs, protocol.TextEdit{
			Range: protocol.Range{
				Start: protocol.Position{Line: float64(numOldLines + 1)},
				End:   protocol.Position{Line: float64(numOldLines + 1)},
			},
			NewText: "\n",
		})
	}
	return diffs, nil
}

var nlBytes = []byte("\n")

func parseSpan(text string) (start, end int) {
	i := strings.Index(text, ",")
	if i < 0 {
		n, err := strconv.Atoi(text)
		if err != nil {
			log.Printf("cannot parse span %q", text)
			return 0, 0
		}
		return n, n
	}
	start, err1 := strconv.Atoi(text[:i])
	end, err2 := strconv.Atoi(text[i+1:])
	if err1 != nil || err2 != nil {
		log.Printf("cannot parse span %q", text)
		return 0, 0
	}
	return start, end
}

func findLines(text []byte, start, end int) []byte {
	i := 0

	start--
	for ; i < len(text) && start > 0; i++ {
		if text[i] == '\n' {
			start--
			end--
		}
	}
	startByte := i
	for ; i < len(text) && end > 0; i++ {
		if text[i] == '\n' {
			end--
		}
	}
	endByte := i
	return text[startByte:endByte]
}

func tempfile(body []byte) (string, error) {
	f, err := ioutil.TempFile("", "acme-lsp")
	if err != nil {
		return "", err
	}
	if _, err := f.Write(body); err != nil {
		return "", err
	}
	tmp := f.Name()
	f.Close()
	return tmp, nil
}
