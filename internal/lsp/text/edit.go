package text

import (
	"bytes"
	"io"
	"strings"

	"github.com/fhs/acme-lsp/internal/lsp/protocol"
	"github.com/pkg/errors"
)

type File interface {
	// Reader returns a reader for the entire file text buffer ("body" in acme).
	Reader() (io.Reader, error)

	// WriteAt replaces the text in rune range [q0, q1) with bytes b.
	WriteAt(q0, q1 int, b []byte) (int, error)

	// Mark marks the file for later undo.
	Mark() error

	// DisableMark turns off automatic marking (e.g. generated by WriteAt).
	DisableMark() error
}

func Edit(f File, edits []protocol.TextEdit) error {
	if len(edits) == 0 {
		return nil
	}
	reader, err := f.Reader()
	if err != nil {
		return err
	}
	off, err := GetNewlineOffsets(reader)
	if err != nil {
		return errors.Wrapf(err, "failed to obtain newline offsets")
	}

	f.DisableMark()
	f.Mark()

	// Applying the edits in reverse order gets the job done.
	// See https://github.com/golang/go/wiki/gopls#textdocumentformatting-response
	for i := len(edits) - 1; i >= 0; i-- {
		e := edits[i]
		q0 := off.LineToOffset(e.Range.Start.Line, e.Range.Start.Character)
		q1 := off.LineToOffset(e.Range.End.Line, e.Range.End.Character)
		f.WriteAt(q0, q1, []byte(e.NewText))
	}
	return nil
}

var _ = File((*BytesFile)(nil))

type BytesFile []byte

func (f *BytesFile) Reader() (io.Reader, error) {
	return bytes.NewReader(*f), nil
}

func (f *BytesFile) WriteAt(q0, q1 int, b []byte) (int, error) {
	r := []rune(string(*f))

	rr := make([]rune, 0, len(r)+len(b))
	rr = append(rr, r[:q0]...)
	rr = append(rr, []rune(string(b))...)
	rr = append(rr, r[q1:]...)
	*f = []byte(string(rr))
	return len(b), nil
}

func (f *BytesFile) Mark() error {
	return nil
}

func (f *BytesFile) DisableMark() error {
	return nil
}

type AddressableFile interface {
	File

	// Filename returns the filesystem path to the file.
	Filename() (string, error)

	// CurrentAddr returns the address of current selection.
	CurrentAddr() (q0, q1 int, err error)
}

func DocumentURI(f AddressableFile) (uri protocol.DocumentURI, filename string, err error) {
	name, err := f.Filename()
	if err != nil {
		return "", "", err
	}
	return ToURI(name), name, nil
}

func Position(f AddressableFile) (pos *protocol.TextDocumentPositionParams, filename string, err error) {
	name, err := f.Filename()
	if err != nil {
		return nil, "", err
	}
	q0, _, err := f.CurrentAddr()
	if err != nil {
		return nil, "", err
	}
	reader, err := f.Reader()
	if err != nil {
		return nil, "", err
	}
	off, err := GetNewlineOffsets(reader)
	if err != nil {
		return nil, "", err
	}
	line, col := off.OffsetToLine(q0)
	return &protocol.TextDocumentPositionParams{
		TextDocument: protocol.TextDocumentIdentifier{
			URI: ToURI(name),
		},
		Position: protocol.Position{
			Line:      line,
			Character: col,
		},
	}, name, nil
}

// ToURI converts filename to URI.
func ToURI(filename string) protocol.DocumentURI {
	return protocol.DocumentURI("file://" + filename)
}

// ToPath converts URI to filename.
func ToPath(uri protocol.DocumentURI) string {
	return strings.TrimPrefix(string(uri), "file://")
}
